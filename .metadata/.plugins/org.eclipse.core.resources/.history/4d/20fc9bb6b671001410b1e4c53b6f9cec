import java.util.Stack;
import java.util.Queue;
import java.util.LinkedList;

public class Solution {
	
	public static void main(String arg[]){
		String s = ")(((((()())()()))()(()))(";
		Solution ss = new Solution();
		System.out.print(ss.longestValidParentheses(s));
	}
	
	
	// DP get time limited
//	public int longestValidParentheses(String s) {
//        int n = s.length();
//        boolean opt[][] = new boolean[n][n];
//        int max = 0;
//        
//        // base case
//        
//        // iteration
//        for(int offset = 1;offset < n;offset++){
//            for(int i = 0;i < n;i++){
//                int j = i+offset;
//                if(j < n){
//                    if(s.charAt(i)=='(' && s.charAt(j)==')'){
//                        if(opt[i+1][j-1] || i+1==j){opt[i][j] = true;}
//                        for(int t = i;t < j-1;t++)
//                            if(opt[i][t] && opt[t+1][j])
//                                opt[i][j] = true;
//                    }
//                    if(opt[i][j]){
//                        if(j-i+1 > max)
//                            max = j-i+1;
//                    }
//                }
//            }
//        }
//        return max;
//    }
	
	public int longestValidParentheses(String s) {
        if(s.length() < 2){return 0;}
        boolean isValid[] = new boolean[s.length()-1];
        Queue<Range> queue = new LinkedList<Range>();
        int max = 0;
        
        // find out all "()" position
        for(int i = 0;i < s.length()-1;i++)
            if(s.charAt(i) == '(' && s.charAt(i+1)==')')
                isValid[i] = true;
        
        // dfs to extend valid parentheses
        for(int i = 0;i < isValid.length;i++){
            if(isValid[i]){
                int begin = i;
                int end = i+1;
                boolean extended = true;;
                while(extended){
                    extended = false;
                    if(end+1 < isValid.length){
                        if(isValid[end+1]){
                            end += 2;
                            extended = true;
                        }
                    }
                    if(begin-2 >= 0){
                        if(isValid[begin-2]){
                            begin -= 2;
                            extended = true;
                        }
                    }
                    if(begin > 0 && end < s.length()-1){
                        if(s.charAt(begin-1) == '(' && s.charAt(end+1)==')'){
                            begin--;
                            end++;
                            extended = true;
                        }
                    }
                }
                i = end;
                Range range = new Range(begin,end);
                queue.add(range);
            }
        }
        
        // connect consecutive ranges
        Range preRange, curRange;
        int begin, end;
        if(!queue.isEmpty()){
            preRange = queue.poll();
            begin = preRange.begin;
            end = preRange.end;
            while(!queue.isEmpty()){
                curRange = queue.poll();
                if(preRange.end+1 >= curRange.begin){
                    end = curRange.end;
                }else{
                    if(end-begin+1 > max)
                        max = end-begin+1;
                    begin = curRange.begin;
                    end = curRange.end;
                }
                preRange = curRange;
            }
            if(end-begin+1 > max)
                max = end-begin+1;
        }
        return max;
    }
}

class Range{
    int begin;
    int end;
    Range(int x,int y){
        begin = x;
        end = y;
    }
}
